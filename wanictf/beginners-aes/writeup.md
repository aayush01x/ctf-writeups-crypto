## beginners_aes

125pt, 453 solves, Beginner

---
This is a problem based on the standard AES-CBC encryption. The key and iv for AES are generated by appending a random byte to the originally defined key and iv. In output, we are given the encrypted flag with hash of the encrypted flag.

As the possiblities used for key and iv are too less, we can just bruteforce over all possibilities, decrypt using them and check if the hash of the obtained flag matches with the given hash or not.

**solve.py**
```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import hashlib

enc = b'\x16\x97,\xa7\xfb_\xf3\x15.\x87jKRaF&"\xb6\xc4x\xf4.K\xd77j\xe5MLI_y\xd96\xf1$\xc5\xa3\x03\x990Q^\xc0\x17M2\x18'
flag_hash = '6a96111d69e015a07e96dcd141d31e7fc81c4420dbbef75aef5201809093210e'
key = b'the_enc_key_is_'
iv = b'my_great_iv_is_'
for k in range(256):
    for i in range(256):
        key_n = key + bytes([k])
        iv_n = iv+ bytes([i])
        cipher = AES.new(key_n, AES.MODE_CBC, iv_n)
        plain = cipher.decrypt(enc)
        try:
            plain = unpad(plain, 16)
            hashf = hashlib.sha256(plain).hexdigest()
            if hashf == flag_hash:
                print(f"Found flag:{plain.decode('utf-8')}")
        except Exception as e:
            continue
```


Flag:`FLAG{7h3_f1r57_5t3p_t0_Crypt0!!}`
